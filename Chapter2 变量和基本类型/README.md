# Chapter2 变量和基本类型

## 说明

> 由于之前学习过 C 语言和一部分 C++ 的内容，因此这里主要把一些之前不太熟悉的部分记录下来，这里感觉叫 C2C++ 比较好

## 记录笔记

### 2.1 基本内置类型

- 对于类型的建议：

  - 使用 `int` 执行整数运算，但是数值太大的话需要使用 `long long` 。

  - 在算数表达式中不要使用 `bool` ，当我们把一个非布尔类型的算术值赋给布尔类型时，初始值为 0 则结果为 false，初始值为 1 则结果为 true。

  - 执行浮点运算采用 `double` 。

  - 切勿混用带符号类型和无符号类型。

- 字符和字符串字面值：

  - 当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式：

```c++
cout << "a really, really long strng literal "
  "that spans two lines" << endl;
```

### 2.2 变量

- 初始化与赋值：C++11 中可以采用列表的方式进行初始化与赋值，比如 `int units_sold = {0}` 。

  - 初始化：创建变量时赋予其一个初始值。

  - 赋值：把对象的当前值擦除，以一个新值来替代。

- 变量声明和定义的关系：一个变量只能被定义一次，但是可以被多次声明。`extern int i ` 声明 i，`int i ` 声明并定义了 i 。

  - 声明：使得名字为程序所知，文件想使用别处定义的名字时必须包含对那个名字的声明。

  - 定义：创建与名字关联的实体，建议在第一次使用变量时再定义它。

- 变量命名规范：

  - 变量名要有实际意义。

  - 变量名一般用小写字母，如 `index` 。

  - 用户自定义的类名一般以大写字母开头，如 `Sales_item` 。

  - 变量名如果由多个单词组成则需要使用下划线分割，如`student_load`，或者使用驼峰法进行区分，如`studentLoad` 。

### 2.3 复合类型

#### 2.3.1 引用

- 引用**并非对象**，它只是为一个已经存在的对象所起的另外一个名字，对引用的所有操作都是在与之绑定的对象上进行的，引用的三个关键点：

  - 必须绑定到一个对象上。

  - 类型匹配。

  - 初始化常量引用时可以用任意表达式作为初始值，只要该表达式在转换后满足引用的要求即可。

```c++
int ival = 1024;
int &refVal1 = ival; // 引用 refVal 指向 ival
/* ----------下面是几个错误的例子 ---------- */
int &refVal2; // 错误：因为引用必须绑定到一个明确的对象上，所以一定要初始化。
int &refVal3 = 10; // 错误：引用类型的初始值必须是一个对象。
double dval = 3.14;
int &refVal4 = dval;// 错误：此处引用类型的初始值必须是 int 对象。
/* ----------下面是 const 的例子 ---------- */
int i = 42;
const int &r1 = i;
const int &r2 = 42;
```

#### 2.3.2 指针

- 获取对象的地址：使用取地址符 `&`，例如 `&ival` 就表示变量 `ival` 的地址，指针指向表示变量的地址。

```c++
int ival = 42;
int *p = &ival;
```

- 利用指针访问对象：使用解引用符 `*` ，例如 `*p` 就表示指针 `p` 所指向的对象。

- 空指针：在 C++11 的新标准下尽量使用 `nullptr` 表示空指针，而不是 `NULL` 。

#### 2.3.3 复合类型的声明

- 定义多个变量：在同一条定义语句中，基本数据类型只能有一个，但是声明符却可以不同，例如 `int i = 1024, *p = &i, &r = i` ，i 是一个 int 型的数，p 是一个 int 型的指针， r 是一个 int 型的引用，因此在定义多个变量时声明符也都要加对，比如想定义两个 int 型的指针，则需要 `int *p1,  *p2` ，而不是 `int* pq, p2` 。

- 指向指针的引用：指针是一个对象，因此存在指针的引用。

```c++
int i = 42;
int *p;  // p 是一个 int 型指针
int *&r = p; // r 是对指针 p 的引用

r = &i; // 相当于 p = &i
*r = 0; // 相当于 *p = 0，相当于 i = 0
```

**面对复杂的指针或引用的声明语句时，从右往左读。**

### 2.4 const 限定符

- 作用

  - 使用 `const` 可以对变量加以限定，防止程序不小心改变了这个值，因为 `const` 对象一旦创建后其值就不能改变了，因此这个对象一定要**初始化**。

  - 默认状态下 `const` 对象仅在文件内有效，如果想在多个文件之间共享该对象，则需要增加 `extern` 关键字，例如可以在一个文件中定义 `extern const int bufSize = 100 ` ，并在另一个文件中声明 `extern const int bufSize` ，则这两个文件中都表示这个 `bufSize` 变量。

#### 2.4.1 const 的引用

- 可以把引用绑定到 `const` 对象上：

```c++
const int c1 = 1024;
const int &r1 = c1; // 正确：引用及其对应的对象都是常量
r1 = 42; // 错误：r1 是对常量的引用，因此其值不能被修改
int &r2 = c1; // 错误：试图让一个非常量引用指向一个常量对象
```

- `const` 引用可以引一个非 `const` 对象：

```c++
const int c1 = 1024;
int &r1 = c1;
const int &r2 = c1;
r1 = 0; // 正确：r1 并非常量
r2 = 0; // 错误：r2 是一个常量
```

#### 2.4.2 const 的指针

- 指向常量的指针 `const int* ptr` ：可以更改指针指向，但不能改变指针指向对象的值。

```c++
int i = 10, j = 20;
const int* ptr = &i;   // 指向常量的指针
*ptr = 100;  // 错误：不能改变指针指向对象的值
ptr = &j; // 正确：可以改变指针的指向
```

- 指向变量的常量指针`int* const ptr` ：可以更改指针指向对象的值，但不能改变指针指向。

```c++
int i = 10, j = 20;
int* const ptr = &i;   // 指向变量的常量指针
*ptr = 100;  // 正确：可以改变指针指向对象的值
ptr = &j; // 错误：不能改变指针的指向
```

- 指向常量的常量指针 `const int* const ptr` ：指针指向与其指向对象的值均不可修改。

#### 2.4.3 constexpr  说明符

- constexpr 是 C++ 11 中添加的一项功能，主要思想是通过在编译时而不是运行时进行计算来提高程序的性能，下面这段代码最终会输出 200。

```c++
#include<iostream>
using namespace std;
constexpr int product(int x, int y) { return (x * y); }
int main()
{
    constexpr int x = product(10, 20);
    cout << x;
    return 0;
}
```

### 2.5 C++ 中的类型推断

#### 2.5.1 auto 关键字

- 让编译器替我们去分析表达式所属的类型，一种常用的情景就是在迭代器的循环中。

```c++
set<string> st;
st.insert({ "geeks", "for", "geeks", "org" });

// 进行迭代
for (auto it = st.begin(); it != st.end(); it++)
  cout << *it << " ";
```

#### 2.5.2 decltype 关键字

- 从表达式的类型推断出要定义的变量的类型，下面是几个应用的例子：

```c++
int fun1() { return 10; }
int y = 5;
// x 的类型与函数 fun1 的返回类型一致
decltype(fun1()) x;
// z 的类型与 y 的类型一致，均为 int
decltype(y) z = y + 5;
```

**区别**：`auto` 声明具有特定类型的变量，而 `decltype`是从变量中提取类型。

### 2.6 编写自己的头文件

- 注意事项：需要加入头文件保护符，以确保其唯一性。

```c++
#ifndef SALES_DATA_H
#define SALES_DATA_H

代码部分

#endif
```

## 参考资料

- [geeksforgeeks](https://www.geeksforgeeks.org/)
