# Chapter 9 顺序容器

## 说明

> 这里面包含许多具体的用法，因此只是大致梳理逻辑与结构，很多具体的用法就略去了，之后可以看书。

## 记录笔记

### 顺序容器概述

#### 顺序容器的类型

- `vector` 可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢。

- `deque` 双端队列，支持快速随机访问，在头尾位置插入/删除速度很快。

- `list` 双向链表，只支出双向顺序访问，在任何位置插入/删除都很快。

- `forward_list` 单向链表。只支持单向顺序访问，在任何位置插入/删除都很快。

- `array` 固定大小数组，支持快速随机访问，不能添加或删除元素。

- `string` 与 vector 相似的容器，专门用来保存字符。

一般用 `vector` 就够了。

### 容器库概述

#### 迭代器

- 迭代器范围是左闭合区间，`[begin, end)` 。

  - 如果 `begin` 与 `end` 相等，则容器内没有元素。

  - 如果 `begin` 与 `end` 不等，则容器内至少有一个元素，且 `begin` 指向第一个元素。

#### 定义与初始化

- 常用的四种方式：

  - 默认初始化：`vector<const char*> articles` 。

  - 使用列表进行初始化：`list authors = {"Milton", "Shakespeare", "Austen"}` 。

  - 拷贝初始化：`list<string> list2(authors)` ，注意容器类型需要完全匹配。

  - 使用迭代器范围进行初始化：拷贝元素，直到（但不包含）it 指向的元素 `deque<string> authList(authors.begin(), it)` 。

#### 赋值

- 使用 assign：可以将某个容器中的元素替换为迭代器指定范围内的元素的拷贝。

```C++
list<string> names;
vector<const char* oldstyle;
names.assign(oldstyle.cbegin(), oldstyle.cend());
```

- 使用 swap：交换两个相同类型容器的内容。

```C++
vector<string> svec1(10);
vector<string> svec2(24);
swap(svec1, svec2);
```

调用 swap 后，svec1 将包含 24 个 string 元素，svec2 将包含 10 个 string 元素。

#### 关系运算符

- 我感觉这个是比较重要的，因为这个关系运算符的使用可以对容器的整体进行比较。下面是一个例子：

```C++
vector<int> v1 = {1, 3, 5, 7, 9, 12};
vector<int> v2 = {1, 3, 9};
vector<int> v3 = {1, 3, 5, 7};
vector<int> v4 = {1, 3, 5, 7, 9, 12};

v1 < v2  // true，v2[2] 更大
v1 < v3  // false, v3 中元素数量更少
v1 == v4 // true
v1 == v2 // false

```

### 顺序容器操作

#### 添加元素

- `push_back` ：将一个元素追加到容器的尾部，除了 array 以及 forward_list 外，剩下的顺序容器都支持这个操作。

- `push_front`：将一个元素插入到容器的头部，list、forward_list 以及 deque 容器支持这个操作。

- `insert` ：在容器的特定位置插入元素，也可以插入一个范围内的元素。该函数返回指向第一个新加入元素的迭代器，通过使用它的返回值，也可以在容器的一个特定的位置反复插入元素。

- 使用 emplace 操作：一共有三个函数，分别是 `emplace_front` ，`emplace` 以及 `emplace_back` ，将参数传递给元素类型的构造函数。例如：`c.emplace_back("12345678", 25, 15.99)` 可以构造一个 sales_data 对象。

#### 访问元素

- 可以使用迭代器直接访问元素。

- `c.back()` ：返回 c 中尾元素的引用。

- `c.front()` ：返回 c 中首元素的引用。

- `c[n]` ：使用下标引用。

- `c.at(n)` ：返回下标为 n 的元素的引用，如果下标越界，则抛出一个 out_of_range 异常，可以实现安全访问。

#### 删除元素

- `c.pop_back()` ：删除 c 中尾元素。

- `c.pop_front()` ：删除 c 中首元素。

- `c.erase(p)` ：删除迭代器 p 指向的元素，返回指向被删元素后的元素迭代器。

- `c.erase(b, e)` ：删除迭代器 b 和 e 范围内的元素，返回指向被删最后一个元素后的元素迭代器。

- `c.clear()` ：删除 c 中的所有元素。

#### 改变容器大小

- 可以使用 resize 来增大或缩小容器：

  - 当前大小大于所要求大小，容器后部的元素会被删除。

  - 当前大小小于新大小，会将新元素添加到容器后面。

**注意：容器操作可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确地重新定位迭代器。**

### vector 对象的增长方式

- 为了支持快速随机访问，vector 将元素连续存储。因此当容器增长时，容器必须重新分配空间来保存已有的元素以及新元素，将已有的元素从旧位置移动到新空间中，然后添加新元素，释放旧存储空间，因此为了保证性能，vector 每一次扩容会分配的比需求更大一些，以减少扩容的次数。

- `c.size()` ：实际的元素个数。

- `c.capacity()` ：扩容的容量，比实际元素个数多。

### string 操作

整体与 vector 非常类似，下面补充几个与 vector 不同的操作：

- `s.substr(pos, n)` ：取出子串，返回一个 string，包含 s 中从 pos 开始的 n 个字符的拷贝。

- 搜索操作：可以使用 `s.find(args)` 等函数完成搜索，搜索到的话就返回匹配发生位置的下标，没有搜索到的话就返回 `string::npos` 。

- compare 函数，可以实现与 C 语言中 strcmp 类似的功能。

- 数值转换：可以实现数值到 string 以及 string 到数值的转换。

### 容器适配器

- 一种容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。例如 stack 适配器接受一个顺序容器，并使其操作起来就像一个 stack 一样。

- 栈适配器 stack：默认基于 deque 实现，支持的基本操作为 `s.pop()` ，`s.push(item)` ，`s.top()` 。

- 队列适配器 queue：默认基于 deque 实现，支持的基本操作为 `q.pop()` ，`q.front()` ，`q.push(item)` 。
