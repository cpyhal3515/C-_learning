# Chapter3 字符串、向量和数组

## 说明

> 由于之前学习过 C 语言和一部分 C++ 的内容，因此这里主要把一些之前不太熟悉的部分记录下来，这里感觉叫 C2C++ 比较好

## 记录笔记

### 3.2 标准库类型 string

#### 3.2.1 定义与初始化

- 常用的初始化方法：

  - `string s1` ：默认初始化，s1 是一个空字符串。

  - `string s2 = s1` ：用 s1 的值来初始化字符串 s2。

  - `string s3 = "value"` ：用字面值 "value" 来初始化字符串 s3。

  - `string s4(n, 'c')` ：将 s4 初始化成由连续 n 个字符 'c' 组成的串。

#### 3.2.2 string 对象上的操作

- 读写：采用 `cin >> str` ，`cout << str` 可以完成 string 对象的读写，注意在执行读取操作时，string 对象会**自动忽略开头的空白，从第一个真正的字符开始读起，直到遇见下一处空白为止。**另一种读取方式是采用 `getline(cin, str)` 完成一行的读取，`getline` 会读取一行直到遇到第一个换行符为止（换行符会被读入，但是不会存在 string 对象中）。

- 判断空 && 计算字符串大小：

  - `str.empty()` 可以判断一个字符串是否为空字符串，返回 bool 类型的值。

  - `str.size()` 返回 string 对象的长度，注意如果一条表达式中已经有了 `size()` 就不要再使用 int 了，这样可以避免 int 与 unsigned 混用带来的问题。

- 比较：`==` ，`!=` ，`>` ，`<` 。

- 相加 `+`：

  - string 对象相加可以得到一个新的 string 对象，相加的连个 string 对象实际上完成的是拼接操作。

  - string 对象与字符字面值或者字符串字面值相加，结果会被转变为 string 对象，需要注意 string 对象与字符字面值混用时，必须确保 `+` 的两侧的运算对象至少有一个是 string 类型，比如下面这个就不行 `string str = "Hello" + "World"` 。

#### 3.2.3 处理 string 对象中的字符

- 使用范围 for 语句，处理字符串中的每个字符：

```C++
// 只是处理单个字符
string str = "some string";
for(auto c : str)
  {
    cout << c << endl;
  }
// 改变字符串中的字符，增加引用 &
string str = "some string";
for(auto &c : str)
  {
    c = toupper(c);
  }
cout << str << endl; // 变成 SOME STRING
```

- 使用下标，处理字符串中的部分字符：这里就类似 C 语言中的 char\* 类型的数据了。

- 使用迭代器。

### 3.3 标准库类型 vector

> &#x20;vector 是一个类模板，本身不是类或者函数，可以看做是对类或者函数的一份说明，编译器使用实例化方法根据模板创建类或者函数，但是程序员需要在模板后面的尖括号里面放上需要示例化成的类的对应信息。

- 实例化方法：

```C++
vector<int> ivec; //ivec 保存 int 类型得到对象
vector<vector<int>> file; // 该向量的元素是 vector 对象
```

#### 3.3.1 定义与初始化

- 常用的初始化方法：

  - `vector<T> v1` ：默认初始化，v1 是一个空的 vector。

  - `vector<T> v2 = v1` ：v2 中包含有 v1 中所有元素的副本。

  - `vector<T> v3(n, val)` ：用 n 个 相同的 val 值来初始化 v3。

  - `vector<T> v4 = {a,b,c,...}` ：包含需要初始化的元素。

#### 3.3.2 向 vector 对象添加元素

- 使用 `push_back()`，例如：

```c++
vector<int> v2;
for(int i = 0; i != 100; i++)
  v2.push_back(i);
```

- **vector 对象能高效增长**：除非一开始 vector 中的对象的值都一样，否则没有必要在一开始指定 vector 对象的大小。

#### 3.3.3 vector 对象上的操作

- 判断空 && 计算字符串大小：

  - `vec.empty()` 可以判断一个字符串是否为空字符串，返回 bool 类型的值。

  - `vec.size()` 返回 vector 对象的长度。

- 比较：`==` ，`!=` ，`>` ，`<` 。

### 3.4 迭代器

- 迭代器提供对对象的间接访问，就迭代器而言，其对象是容器中的元素或者 string 对象中的字符。

- **泛型编程**：所有标准库容器都定义了 `==` 以及 `!=` 运算符，但是大多没有定义 `<` 运算符，因此养成使用 `==` 以及 `!=` 的习惯就可以不用太在意使用的到底是哪种容器类型。

- 迭代器的应用

  - 一般我们不是很关注迭代器的类型，因此一般采用 `auto` 形式指示迭代器的类型。

  - `begin()`是指向第一个元素的迭代器，`end()` 是指向尾元素的**下一位置**的迭代器，如果容器为空，则 `begin` 与 `end` 返回的是同一个迭代器。

  - 解引用迭代器可以得到迭代器所指的对象 `*it`，如果该对象恰好为类，则可能进一步去访问类中的成员，可以采用`(*it).mem() `也可以采用 `it->mem()`的方式。

```C++
for(auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
  *it = toupper(*it);
```

- 迭代器的运算

  - `==` ，`!=` ，`>` ，`<` ，`>=` ，`<=` 。

  - `iter +/- n` ：迭代器指示的新位置相比于原位置移动了 n 个元素，结果返回还是一个迭代器。

  - `iter1 - iter2` ：计算两个迭代器之间的距离，要求两个迭代器指向同一个容器。

### 3.5 数组

**尽量使用标准库类型而非数组**：现在的 C++程序应该尽量使用 vector 和迭代器，避免使用内置的数组和指针；应该尽量使用 string，避免使用 C 风格的基于数组的字符串。
